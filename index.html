<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:opsz,wght@17..18,400..700&display=swap" rel="stylesheet">
  <title>SHIFT SCHEDULE 2026</title>
  <style>
    :root {
      --bg: whitesmoke;
      --card: #fbfbfb;
      --muted: #6b7280;
      --border: lightslategray;
      --border-style: 2px solid var(--border);
      --primary: #4565fe;
      --primary-border-style: 2px solid var(--primary);
      --morning: #166534;
      --evening: #b91c1c;
      --night: #6b7280;
      --rest: antiquewhite;
      --off: antiquewhite;
      
      /* Base scale factor */
      --scale: 1;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      overflow: hidden;
      font-family: "Google Sans", sans-serif;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh;
      padding: calc(8px * var(--scale));
      padding-bottom: calc(16px * var(--scale) + env(safe-area-inset-bottom));
    }

    .header {
      position: relative;
      align-items: center;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      padding: calc(8px * var(--scale));
      background: var(--card);
      border: var(--border-style);
      border-radius: calc(8px * var(--scale));
    }

    .filters {
      align-items: center;
      display: flex;
      gap: calc(8px * var(--scale));
    }

    .filter-pill {
      padding: calc(8px * var(--scale));
      font-family: inherit;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      cursor: pointer;
      transition: all .15s ease;
      border-radius: calc(8px * var(--scale));
    }

    .filter-pill.active {
      color: var(--card);
      background: var(--primary);
      border: var(--primary-border-style);
    }

    .filter-pill:not(.active) {
      background: var(--card);
      border: var(--border-style);
    }

    .filter-pill:not(.active):hover {
      color: var(--primary);
      border: var(--primary-border-style);
      opacity: 1;
    }

    .month-control {
      position: absolute;
      align-items: center;
      display: flex;
      left: 50%;
      gap: calc(8px * var(--scale));
      transform: translate(-50%);
    }

    .month-control button {
      align-items: center;
      display: inline-flex;
      justify-content: center;
      padding: calc(5px * var(--scale));
      background: var(--primary);
      border: var(--primary-border-style);
      cursor: pointer;
      border-radius: calc(8px * var(--scale));
    }

    .icon-btn svg { 
      display: block;
      width: calc(24px * var(--scale));
      height: calc(24px * var(--scale));
      stroke: var(--card);
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .month-label {
      display: inline-block;
      width: calc(130px * var(--scale));
      font-family: inherit;
      font-size: calc(16px * var(--scale));
      font-weight: 600;
      text-align: center;
    }

    .download {
      align-items: center;
      display: flex;
    }

    .download-btn {
      padding: calc(8px * var(--scale));
      font-family: inherit;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      color: var(--card);
      background: var(--primary);
      border: var(--primary-border-style);
      cursor: pointer;
      border-radius: calc(8px * var(--scale));
    }

    .calendar {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      margin-top: calc(8px * var(--scale));
      overflow: hidden;
      padding: calc(8px * var(--scale));
      padding-bottom: calc(16px * var(--scale) + env(safe-area-inset-bottom));
      background: var(--card);
      border: var(--border-style);
      border-radius: calc(8px * var(--scale));
    }

    .calendar-grid-container {
      flex-grow: 1;
      overflow-y: scroll;
      padding-bottom: calc(8px * var(--scale));
      -webkit-overflow-scrolling: touch;
    }

    .calendar-grid {
      display: grid;
      padding-right: calc(8px * var(--scale));
      grid-template-columns: repeat(7, 1fr);
      gap: calc(8px * var(--scale));
    }

    .day-name {
      position: sticky;
      top: 0;
      z-index: 5;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      text-align: center;
      background: var(--card);
      border-bottom: var(--border-style);
    }

    .day {
      padding: calc(8px * var(--scale));
      background: var(--card);
      border: var(--border-style);
      border-radius: calc(8px * var(--scale));
    }

    .date {
      margin-bottom: calc(4px * var(--scale));
      font-size: calc(12px * var(--scale));
      font-weight: 600;
    }

    .person {
      align-items: center;
      display: flex;
      margin-bottom: calc(4px * var(--scale));
      gap: calc(6px * var(--scale));
    }

    .name-pill {
      font-size: calc(12px * var(--scale));
      font-weight: 600;
    }

    .shift-pill {
      padding: calc(2px * var(--scale)) calc(6px * var(--scale));
      font-size: calc(11px * var(--scale));
      white-space: nowrap;
      color: var(--card);
      border-radius: calc(6px * var(--scale));
    }

    .work-cycle-label {
      font-size: calc(11px * var(--scale));
      color: var(--muted);
    }

    .morning { background: var(--morning); }
    .evening { background: var(--evening); }
    .night { background: var(--night); }
    .rest { background: var(--rest); color: black}
    .off { background: var(--off); color: black}

    .modal {
      position: fixed;
      display: none;
      height: 100%;
      left: 0;
      top: 0;
      width: 100%;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.2s;
    }

    .modal.show {
      align-items: center;
      display: flex;
      justify-content: center;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal-content {
      display: flex;
      flex-direction: column;
      max-height: 60vh;
      max-width: 40vw;
      background: var(--card);
      animation: slideIn 0.3s;
      border-radius: calc(8px * var(--scale));
    }

    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-header {
      align-items: center;
      display: flex;
      justify-content: flex-start;
      padding: calc(8px * var(--scale));
      border-bottom: var(--border-style);
    }

    .modal-header h2 {
      margin: 0;
      font-size: calc(16px * var(--scale));
      font-weight: 600;
    }

    .modal-body {
      flex: 1;
      padding: calc(8px * var(--scale));
    }

    .modal-section {
      margin-bottom: calc(8px * var(--scale));
    }

    .modal-section:last-child {
      margin-bottom: 0;
    }

    .modal-section h3 {
      margin: 0 0 calc(8px * var(--scale)) 0;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
    }

    .modal-filters {
      display: flex;
      flex-wrap: wrap;
      gap: calc(8px * var(--scale));
    }

    .modal-filter-pill {
      padding: calc(8px * var(--scale));
      font-family: inherit;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      background: var(--card);
      border: var(--border-style);
      cursor: pointer;
      transition: all 0.15s;
      border-radius: calc(8px * var(--scale));  
    }

    .modal-filter-pill:hover {
      color: var(--primary);
      background: var(--card);
      border: var(--primary-border-style);
    }

    .modal-filter-pill.active {
      color: var(--card);
      background: var(--primary);
      border: var(--primary-border-style);
    }

    .modal-footer {
      align-items: center;
      display: flex;
      justify-content: flex-end;
      padding: calc(8px * var(--scale));
      border-top: var(--border-style);
      gap: calc(8px * var(--scale));
    }

    .modal-btn {
      padding: calc(8px * var(--scale));
      font-family: inherit;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      border: var(--border-style);
      cursor: pointer;
      transition: all 0.15s;
      border-radius: calc(8px * var(--scale));
    }

    .modal-btn-cancel {
      background: var(--card);
    }

    .modal-btn-cancel:hover {
      color: var(--primary);
      background: var(--card);
      border: var(--primary-border-style);
    }

    .modal-btn-confirm {
      color: var(--card);
      background: var(--primary);
      border: var(--primary-border-style);
    }

    .modal-btn-confirm:disabled {
      color: var(--card);
      background: var(--primary);
      border: var(--primary-border-style);
      cursor: not-allowed;
      opacity: 0.8;
    }

    .modal-header.preview-header {
      flex-direction: column;
      align-items: flex-start;
    }

    .modal-body.preview-modal-body {
      padding-bottom: 0;
    }

    .preview-instruction {
      font-size: calc(12px * var(--scale));
      text-align: left;
      color: var(--muted);
    }

    .preview-modal-body {
      align-items: center;
      display: flex;
      flex-direction: column;
      overflow-y: scroll;
    }

    .preview-wrap {
      align-items: center;
      display: flex;
      flex-direction: column;
      max-width: 100%;
    }

    .preview-img {
      max-width: 100%;
      cursor: pointer;
    }

    .preview-label {
      padding: 0px calc(8px * var(--scale)) calc(8px * var(--scale)) calc(8px * var(--scale));
      width: 100%;
      font-size: calc(13px * var(--scale));
      font-weight: 600;
      text-align: center;
      word-break: break-word;
      color: var(--muted);
    }

    /* export-mode stylesheet removed (unused) */
    
    /* Tablet devices (768px and below) */
    @media (max-width: 768px) {
      :root {
        --scale: 0.85;
      }

      .header {
        flex-direction: column;
        gap: calc(12px * var(--scale));
      }

      .month-control {
        position: static;
        transform: none;
      }

      .filters {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }

      .download {
        width: 100%;
        justify-content: center;
      }

      .modal-content {
        width: 90%;
        max-width: 90%;
        max-height: 85vh;
      }
    }

    /* Mobile devices (480px and below) */
    @media (max-width: 480px) {
      :root {
        --scale: 0.6;
      }

      body {
        padding-bottom: max(env(safe-area-inset-bottom), 16px);
      }

      .container {
        height: 100dvh;
        padding-bottom: calc(24px * var(--scale) + env(safe-area-inset-bottom));
      }

      .header {
        flex-direction: column;
        gap: calc(10px * var(--scale));
      }

      .month-control {
        position: static;
        transform: none;
      }

      .filters {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
      }

      .download {
        width: 100%;
        justify-content: center;
      }

      .calendar {
        padding-bottom: calc(24px * var(--scale) + env(safe-area-inset-bottom));
      }

      .modal-content {
        width: 95%;
        max-width: 95%;
        max-height: 90vh;
        max-height: 90dvh;
      }

      .modal-footer {
        flex-direction: column;
      }

      .modal-btn {
        width: 100%;
      }
    }

    /* Extra small devices (360px and below) */
    @media (max-width: 360px) {
      :root {
        --scale: 0.6;
      }

      .container {
        padding: calc(6px * var(--scale));
        padding-bottom: calc(24px * var(--scale) + env(safe-area-inset-bottom));
      }

      .calendar {
        margin-top: calc(6px * var(--scale));
        padding-bottom: calc(24px * var(--scale) + env(safe-area-inset-bottom));
      }

      .modal-content {
        width: 98%;
        max-width: 98%;
        max-height: 92vh;
        max-height: 92dvh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="month-control">
        <button id="prevMonth" class="icon-btn" type="button" aria-label="Previous month">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon-svg"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <span id="monthLabel" class="month-label"></span>
        <button id="nextMonth" class="icon-btn" type="button" aria-label="Next month">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="icon-svg"><path d="M9 18l6-6-6-6"/></svg>
        </button>
      </div>

      <div class="download">
        <button id="downloadBtn" class="download-btn" type="button">Download Schedule as Image</button>
      </div>
    </div>

    <div class="calendar">
      <div class="calendar-grid-container">
        <div class="calendar-grid" id="calendarGrid"></div>
      </div>
    </div>
  </div>

  <div id="downloadModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Download Schedule</h2>
      </div>
      <div class="modal-body">
        <div class="modal-section">
          <h3>Select Team</h3>
          <div id="personFilters" class="modal-filters"></div>
        </div>
        <div class="modal-section">
          <h3>Select Month</h3>
          <div id="monthFilters" class="modal-filters"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button id="cancelDownload" class="modal-btn modal-btn-cancel">Cancel</button>
        <button id="confirmDownload" class="modal-btn modal-btn-confirm">Next</button>
      </div>
    </div>
  </div>

  <!-- Preview modal: show generated image(s) before actual download -->
  <div id="previewModal" class="modal">
    <div class="modal-content">
      <div class="modal-header preview-header">
        <h2>Schedule Preview</h2>
        <div class="preview-instruction">
          Click any image to download the schedule
        </div>
      </div>

      <div class="modal-body preview-modal-body">
        <div id="previewList" class="preview-list"></div>
      </div>
      <div class="modal-footer preview-modal-footer">
         <button id="backPreview" class="modal-btn modal-btn-cancel" type="button">Back</button>
         <button id="closePreview" class="modal-btn modal-btn-cancel" type="button">Close</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    const teams = ['SITI', 'IRA', 'EKIN', 'BALQIS'];
    
    const SHIFT_LABELS = {
      morning: 'Morning',
      evening: 'Evening',
      night: 'Night',
      off: 'Off',
      rest: 'Rest'
    };

    // clamp range for display
    const MIN_MONTH = new Date(2026, 0, 1);   // Jan 2026
    const MAX_MONTH = new Date(2026, 11, 1);  // Dec 2026

    function clampMonth(date) {
      // normalize to first of month
      const d = new Date(date.getFullYear(), date.getMonth(), 1);
      if (d < MIN_MONTH) return new Date(MIN_MONTH);
      if (d > MAX_MONTH) return new Date(MAX_MONTH);
      return d;
    }

    // start with current month but clamp into 2026 range
    let currentDate = clampMonth(new Date());

    const grid = document.getElementById('calendarGrid');
    const label = document.getElementById('monthLabel');

    // active filter set - start with ALL teams selected by default
    const activeTeams = new Set(teams);

    // --- NEW: scheduling rules anchored at 1 Jan 2026 ---
    const START_DATE = new Date(2026, 0, 1); // Jan 1, 2026

    // work cycle positions (1..8): Day1..Day6, Off (7), Rest (8)
    const CYCLE_LENGTH = 8;

    // shift block order -- each block is 8 days (6 work + 2 off)
    const SHIFT_ORDER = ['morning', 'night', 'evening'];

    // initial state on 1 Jan 2026 as supplied
    const initialState = {
      'SITI': { shift: 'evening', cycleIndex: 5 },   // Day 5
      'IRA':  { shift: 'night', cycleIndex: 7 },     // <-- changed to 'night' to match provided daily sequence
      'EKIN': { shift: 'morning', cycleIndex: 3 },   // Day 3
      'BALQIS': { shift: 'night', cycleIndex: 1 }    // Day 1
    };

    // helper: compute assignment for a person on a given date
    function computeAssignment(person, date) {
      const init = initialState[person];
      if (!init) return { shift: 'morning', cycleIndex: 1 };

      // normalize to UTC midnight (do not mutate inputs)
      const dUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
      const sUTC = Date.UTC(START_DATE.getFullYear(), START_DATE.getMonth(), START_DATE.getDate());

      const diffDays = Math.floor((dUTC - sUTC) / (1000 * 60 * 60 * 24));

      // zero-based initial position in 8-day cycle
      const startPos = init.cycleIndex - 1;
      const overallPos = startPos + diffDays;

      // cycle index 1..8 (safe modulo for negatives)
      const mod = ((overallPos % CYCLE_LENGTH) + CYCLE_LENGTH) % CYCLE_LENGTH;
      const cycleIndex = mod + 1;

      // number of completed 8-day blocks since start (can be negative)
      const completedBlocks = Math.floor((startPos + diffDays) / CYCLE_LENGTH);

      // initial shift block index (map shift to SHIFT_ORDER index)
      const initialShiftIndex = SHIFT_ORDER.indexOf(init.shift);
      const shiftIndex = ((initialShiftIndex + completedBlocks) % SHIFT_ORDER.length + SHIFT_ORDER.length) % SHIFT_ORDER.length;
      const shift = (cycleIndex === 7) ? 'off' : (cycleIndex === 8) ? 'rest' : SHIFT_ORDER[shiftIndex];

      return { shift, cycleIndex };
    }

    // create filter pills in header (left side)
    function createFilterPills() {
      const header = document.querySelector('.header');
      const container = document.createElement('div');
      container.className = 'filters';

      // Add "All" button first
      const allBtn = document.createElement('button');
      allBtn.className = 'filter-pill active';
      allBtn.type = 'button';
      allBtn.dataset.name = 'ALL';
      allBtn.textContent = 'All';

      allBtn.addEventListener('click', () => {
        const allActive = activeTeams.size === teams.length;
        
        if (allActive) {
          // Deselect all
          activeTeams.clear();
          allBtn.classList.remove('active');
          container.querySelectorAll('.filter-pill:not([data-name="ALL"])').forEach(btn => {
            btn.classList.remove('active');
          });
        } else {
          // Select all
          teams.forEach(t => activeTeams.add(t));
          allBtn.classList.add('active');
          container.querySelectorAll('.filter-pill:not([data-name="ALL"])').forEach(btn => {
            btn.classList.add('active');
          });
        }
        renderCalendar();
      });

      container.appendChild(allBtn);

      teams.forEach(t => {
        const btn = document.createElement('button');
        // start WITH 'active' class so all buttons are active by default
        btn.className = 'filter-pill active';
        btn.type = 'button';
        btn.dataset.name = t;

        // label text only
        btn.textContent = t;

        // button click toggles filter state
        btn.addEventListener('click', () => {
          const name = btn.dataset.name;
          if (activeTeams.has(name)) {
            activeTeams.delete(name);
            btn.classList.remove('active');
          } else {
            activeTeams.add(name);
            btn.classList.add('active');
          }
          
          // Update "All" button state
          const allBtn = container.querySelector('[data-name="ALL"]');
          if (activeTeams.size === teams.length) {
            allBtn.classList.add('active');
          } else {
            allBtn.classList.remove('active');
          }
          
          renderCalendar();
        });

        container.appendChild(btn);
      });

      // insert filters at start of header
      header.prepend(container);
    }

    function renderCalendar() {
      grid.innerHTML = '';

      const year = currentDate.getFullYear();
      const month = currentDate.getMonth();

      label.textContent = currentDate.toLocaleDateString('en-US', {
        month: 'long',
        year: 'numeric'
      });

      // render weekday names first
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayNames.forEach(d => {
        const dn = document.createElement('div');
        dn.className = 'day-name';
        dn.textContent = d;
        grid.appendChild(dn);
      });

      const firstDay = new Date(year, month, 1).getDay();
      const daysInMonth = new Date(year, month + 1, 0).getDate();

      for (let i = 0; i < firstDay; i++) {
        grid.appendChild(document.createElement('div'));
      }

      // if no teams selected (empty set), show all teams
      const teamsToShow = activeTeams.size === 0 ? teams : Array.from(activeTeams);

      for (let d = 1; d <= daysInMonth; d++) {
        const day = document.createElement('div');
        day.className = 'day';

        const date = document.createElement('div');
        date.className = 'date';
        date.textContent = d;
        day.appendChild(date);

        teams.forEach(name => {
          // skip rendering person if NOT in teamsToShow
          if (!teamsToShow.includes(name)) return;

          const person = document.createElement('div');
          person.className = 'person';

          const namePill = document.createElement('span');
          namePill.className = 'name-pill';
          namePill.textContent = name;

          // compute assignment for this person/date
          const assignDate = new Date(year, month, d);
          const assign = computeAssignment(name, new Date(assignDate)); // pass copy

          const shiftPill = document.createElement('span');
          shiftPill.className = 'shift-pill ' + assign.shift;
          shiftPill.textContent = SHIFT_LABELS[assign.shift] ?? assign.shift;
          let idxMap = { morning: 0, evening: 1, night: 2, rest: 3, off: 4 };
          shiftPill.dataset.index = idxMap[assign.shift] ?? 0;

          // show work cycle pill ONLY for Day 1..6; do NOT show for Off(7) or Rest(8)
          if (assign.cycleIndex >= 1 && assign.cycleIndex <= 6) {
            const workCycle = document.createElement('span');
            workCycle.className = 'work-cycle-label';
            workCycle.textContent = 'D' + assign.cycleIndex;
            workCycle.dataset.cycle = assign.cycleIndex;
            person.appendChild(namePill);
            person.appendChild(shiftPill);
            person.appendChild(workCycle);
          } else {
            // Off / Rest: only show shift pill (no work cycle pill)
            person.appendChild(namePill);
            person.appendChild(shiftPill);
          }

          day.appendChild(person);
        });

        grid.appendChild(day);
      }
    }

    document.getElementById('prevMonth').onclick = () => {
      const candidate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
      if (candidate < MIN_MONTH) {
        currentDate = new Date(MAX_MONTH); // wrap to December 2026
      } else {
        currentDate = clampMonth(candidate);
      }
      renderCalendar();
    };

    document.getElementById('nextMonth').onclick = () => {
      const candidate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
      if (candidate > MAX_MONTH) {
        currentDate = new Date(MIN_MONTH); // wrap to January 2026
      } else {
        currentDate = clampMonth(candidate);
      }
      renderCalendar();
    };

    // init
    createFilterPills();
    renderCalendar();

    // ===== Download Modal Functionality =====
    const modal = document.getElementById('downloadModal');
    const downloadBtn = document.getElementById('downloadBtn');
    const cancelDownload = document.getElementById('cancelDownload');
    const confirmDownload = document.getElementById('confirmDownload');
    const personFilters = document.getElementById('personFilters');
    const monthFilters = document.getElementById('monthFilters');

    // selected filters for download
    const downloadSelection = {
      persons: new Set(),
      months: new Set()
    };

    // make Next disabled by default
    confirmDownload.disabled = true;

    // helper to enable/disable Next button
    function updateConfirmState() {
      const ok = downloadSelection.persons.size > 0 && downloadSelection.months.size > 0;
      confirmDownload.disabled = !ok;
    }

    // open modal when download button clicked
    downloadBtn.addEventListener('click', () => {
      // reset selections
      downloadSelection.persons.clear();
      downloadSelection.months.clear();
      confirmDownload.disabled = true;
      
      // populate person filters
      personFilters.innerHTML = '';
      
      // Add "All" button for persons
      const allPersonBtn = document.createElement('button');
      allPersonBtn.className = 'modal-filter-pill';
      allPersonBtn.textContent = 'All';
      allPersonBtn.dataset.person = 'ALL';
      
      allPersonBtn.addEventListener('click', () => {
        const allActive = downloadSelection.persons.size === teams.length;
        
        if (allActive) {
          // Deselect all
          downloadSelection.persons.clear();
          allPersonBtn.classList.remove('active');
          personFilters.querySelectorAll('.modal-filter-pill:not([data-person="ALL"])').forEach(pill => {
            pill.classList.remove('active');
          });
        } else {
          // Select all
          teams.forEach(t => downloadSelection.persons.add(t));
          allPersonBtn.classList.add('active');
          personFilters.querySelectorAll('.modal-filter-pill:not([data-person="ALL"])').forEach(pill => {
            pill.classList.add('active');
          });
        }
        updateConfirmState();
      });
      
      personFilters.appendChild(allPersonBtn);
      
      teams.forEach(person => {
        const pill = document.createElement('button');
        pill.className = 'modal-filter-pill';
        pill.textContent = person;
        pill.dataset.person = person;
        
        pill.addEventListener('click', () => {
          if (downloadSelection.persons.has(person)) {
            downloadSelection.persons.delete(person);
            pill.classList.remove('active');
          } else {
            downloadSelection.persons.add(person);
            pill.classList.add('active');
          }
          
          // Update "All" button state
          const allBtn = personFilters.querySelector('[data-person="ALL"]');
          if (downloadSelection.persons.size === teams.length) {
            allBtn.classList.add('active');
          } else {
            allBtn.classList.remove('active');
          }
          
          updateConfirmState();
        });
        
        personFilters.appendChild(pill);
      });
      
      // populate month filters (Jan - Dec 2026)
      monthFilters.innerHTML = '';
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                      'July', 'August', 'September', 'October', 'November', 'December'];
      
      // Add "All" button for months
      const allMonthBtn = document.createElement('button');
      allMonthBtn.className = 'modal-filter-pill';
      allMonthBtn.textContent = 'All';
      allMonthBtn.dataset.month = 'ALL';
      
      allMonthBtn.addEventListener('click', () => {
        const allActive = downloadSelection.months.size === 12;
        
        if (allActive) {
          // Deselect all
          downloadSelection.months.clear();
          allMonthBtn.classList.remove('active');
          monthFilters.querySelectorAll('.modal-filter-pill:not([data-month="ALL"])').forEach(pill => {
            pill.classList.remove('active');
          });
        } else {
          // Select all
          months.forEach((_, index) => downloadSelection.months.add(index));
          allMonthBtn.classList.add('active');
          monthFilters.querySelectorAll('.modal-filter-pill:not([data-month="ALL"])').forEach(pill => {
            pill.classList.add('active');
          });
        }
        updateConfirmState();
      });
      
      monthFilters.appendChild(allMonthBtn);
      
      months.forEach((monthName, index) => {
        const pill = document.createElement('button');
        pill.className = 'modal-filter-pill';
        pill.textContent = monthName;
        pill.dataset.month = index;
        
        pill.addEventListener('click', () => {
          if (downloadSelection.months.has(index)) {
            downloadSelection.months.delete(index);
            pill.classList.remove('active');
          } else {
            downloadSelection.months.add(index);
            pill.classList.add('active');
          }
          
          // Update "All" button state
          const allBtn = monthFilters.querySelector('[data-month="ALL"]');
          if (downloadSelection.months.size === 12) {
            allBtn.classList.add('active');
          } else {
            allBtn.classList.remove('active');
          }
          
          updateConfirmState();
        });
        
        monthFilters.appendChild(pill);
      });
      
      modal.classList.add('show');
    });

    // close modal handlers
    cancelDownload.addEventListener('click', () => {
      modal.classList.remove('show');
    });

    // confirm download handler (now generates images then shows preview modal)
    confirmDownload.addEventListener('click', async () => {
      // Disable button and show loading
      const originalText = confirmDownload.textContent;
      confirmDownload.disabled = true;
      confirmDownload.textContent = 'Loading';
      
      // Block all interactions except cancel button
      const modalContent = modal.querySelector('.modal-content');
      modalContent.style.pointerEvents = 'none';
      cancelDownload.style.pointerEvents = 'auto';
      cancelDownload.style.cursor = 'pointer';
      
      // Block clicking outside modal (backdrop click)
      modal.style.pointerEvents = 'none';
      cancelDownload.parentElement.style.pointerEvents = 'auto'; // re-enable footer for cancel button
      
      // Flag to track if user cancelled
      let isCancelled = false;
      
      // Cancel handler - set flag and cleanup
      const cancelHandler = () => {
        isCancelled = true;
      };
      
      // Add one-time cancel listener
      cancelDownload.addEventListener('click', cancelHandler, { once: true });
      
      // Add loading animation
      let dots = 0;
      const loadingInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        confirmDownload.textContent = 'Loading' + '.'.repeat(dots);
      }, 300);

      try {
        // collect selected months in ascending order
        const monthsArray = Array.from(downloadSelection.months).sort((a, b) => a - b);
        if (monthsArray.length === 0) {
          clearInterval(loadingInterval);
          confirmDownload.textContent = originalText;
          confirmDownload.disabled = false;
          modalContent.style.pointerEvents = 'auto';
          modal.style.pointerEvents = 'auto';
          cancelDownload.removeEventListener('click', cancelHandler);
          return;
        }

        // use fixed 6 rows (7 columns x 6 rows)
        const maxRows = 6;

        // collect generated images in ascending month order
        const images = [];
        for (const monthIndex of monthsArray) {
          // Check if cancelled before processing each month
          if (isCancelled) {
            console.log('Image generation cancelled by user');
            break;
          }
          
          const result = await generateCalendarImage(monthIndex, downloadSelection.persons, maxRows);
          images.push(result);
        }

        // Clear loading animation
        clearInterval(loadingInterval);
        confirmDownload.textContent = originalText;
        
        // If cancelled, just cleanup and close modal
        if (isCancelled) {
          confirmDownload.disabled = false;
          modalContent.style.pointerEvents = 'auto';
          modal.style.pointerEvents = 'auto';
          modal.classList.remove('show');
          return;
        }
        
        if (images.length === 0) {
          confirmDownload.disabled = false;
          modalContent.style.pointerEvents = 'auto';
          modal.style.pointerEvents = 'auto';
          cancelDownload.removeEventListener('click', cancelHandler);
          return;
        }

        // close selection modal
        modal.classList.remove('show');
        
        // Reset button state and re-enable interactions
        confirmDownload.disabled = false;
        modalContent.style.pointerEvents = 'auto';
        modal.style.pointerEvents = 'auto';
        
        openPreviewModal(images);
      } catch (error) {
        // Handle error
        clearInterval(loadingInterval);
        confirmDownload.textContent = originalText;
        confirmDownload.disabled = false;
        modalContent.style.pointerEvents = 'auto';
        modal.style.pointerEvents = 'auto';
        cancelDownload.removeEventListener('click', cancelHandler);
        console.error('Error generating calendar images:', error);
      } finally {
        // Always remove the cancel listener when done
        cancelDownload.removeEventListener('click', cancelHandler);
      }
    });

    // generateCalendarImage now accepts optional maxRows to force uniform row height
    async function generateCalendarImage(monthIndex, selectedPersons, maxRows) {
      // Scaling factor for saved images
      const SCALE = 3.6;
      
      // A4 Landscape dimensions at 300 DPI
      const A4_WIDTH = 3508;
      const A4_HEIGHT = 2480;
      
      // Create style element for export-specific scaling
      const styleEl = document.createElement('style');
      styleEl.id = 'export-styles';
      styleEl.textContent = `
        .export-container {
          position: absolute;
          left: -9999px;
          width: ${A4_WIDTH}px;
          height: ${A4_HEIGHT}px;
          background: transparent;
          box-sizing: border-box;
          font-family: "Google Sans", sans-serif;
          overflow: hidden;
        }
        
        .export-calendar {
          height: 100%;
          display: flex;
          flex-direction: column;
          padding: ${6 * SCALE}px;
          background: transparent;
          border: ${2 * SCALE}px solid lightslategray;
          border-radius: ${6 * SCALE}px;
          box-sizing: border-box;
        }
        
        .export-title-block {
          text-align: center;
          margin-bottom: ${6 * SCALE}px;
          flex-shrink: 0;
        }
        
        .export-title {
          margin: 0;
          font-size: ${16 * SCALE}px;
          font-weight: 600;
          font-family: "Google Sans", sans-serif;
          color: #111827;
        }
        
        .export-grid-container {
          flex: 1;
          overflow: hidden;
          min-height: 0;
        }
        
        .export-grid {
          display: grid;
          grid-template-columns: repeat(7, 1fr);
          gap: ${6 * SCALE}px;
          height: 100%;
        }
        
        .export-day-name {
          font-size: ${13 * SCALE}px;
          font-weight: 600;
          text-align: center;
          background: transparent;
          border-bottom: ${2 * SCALE}px solid lightslategray;
          font-family: "Google Sans", sans-serif;
          color: #111827;
          height: fit-content;
          /* remove visual margin — spacing handled by grid track / rowGap */
          box-sizing: border-box;
        }
        
        .export-day {
          padding: ${4 * SCALE}px;
          background: #fbfbfb;
          border: ${2 * SCALE}px solid lightslategray;
          border-radius: ${4 * SCALE}px;
          box-sizing: border-box;
          overflow: hidden;
          display: flex;
          flex-direction: column;
        }
        
        .export-date {
          font-size: ${12 * SCALE}px;
          font-weight: 600;
          margin-bottom: ${2 * SCALE}px;
          color: #111827;
          font-family: "Google Sans", sans-serif;
          flex-shrink: 0;
        }
        
        .export-person {
          align-items: center;
          display: flex;
          margin-bottom: ${2 * SCALE}px;
          gap: ${4 * SCALE}px;
          min-height: 0;
        }
        
        .export-name-pill {
          font-size: ${12 * SCALE}px;
          font-weight: 600;
          color: #111827;
          font-family: "Google Sans", sans-serif;
          white-space: nowrap;
        }
        
        .export-shift-pill {
          font-size: ${11 * SCALE}px;
          padding: ${0 * SCALE}px ${4 * SCALE}px;
          white-space: nowrap;
          color: #fbfbfb;
          border-radius: ${6 * SCALE}px;
          font-family: "Google Sans", sans-serif;
          font-weight: 600;
        }
        
        .export-shift-pill.morning { background: #166534; }
        .export-shift-pill.evening { background: #b91c1c; }
        .export-shift-pill.night { background: #6b7280; }
        .export-shift-pill.rest { background: antiquewhite; color: black; }
        .export-shift-pill.off { background: antiquewhite; color: black; }
        
        .export-work-cycle {
          font-size: ${11 * SCALE}px;
          color: #6b7280;
          font-family: "Google Sans", sans-serif;
          font-weight: 400;
          white-space: nowrap;
        }
        
        .export-empty-day {
          padding: ${4 * SCALE}px;
          background: #fbfbfb;
          border: ${2 * SCALE}px solid lightslategray;
          border-radius: ${4 * SCALE}px;
          box-sizing: border-box;
        }
      `;
      document.head.appendChild(styleEl);
      
      // Create temporary container
      const tempContainer = document.createElement('div');
      tempContainer.className = 'export-container';
      document.body.appendChild(tempContainer);
       
      // Create calendar wrapper
      const calendarWrapper = document.createElement('div');
      calendarWrapper.className = 'export-calendar';
      
      // Add title
      const titleBlock = document.createElement('div');
      titleBlock.className = 'export-title-block';
      const title = document.createElement('h1');
      title.className = 'export-title';
      title.textContent = `${getMonthName(monthIndex)} 2026`;
      titleBlock.appendChild(title);
      calendarWrapper.appendChild(titleBlock);
      
      // Create grid container
      const gridContainer = document.createElement('div');
      gridContainer.className = 'export-grid-container';
      
      const tempGrid = document.createElement('div');
      tempGrid.className = 'export-grid';
      
      gridContainer.appendChild(tempGrid);
      calendarWrapper.appendChild(gridContainer);
      tempContainer.appendChild(calendarWrapper);
       
      // Render calendar
      const year = 2026;
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
       
      // Add day name headers
      dayNames.forEach(d => {
        const dn = document.createElement('div');
        dn.className = 'export-day-name';
        dn.textContent = d;
        tempGrid.appendChild(dn);
      });
       
      const firstDay = new Date(year, monthIndex, 1).getDay();
      const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
       
      // Calculate grid rows (always 6 rows for calendar body)
      const effectiveRows = maxRows || 6; // body rows (row 1..row 6) — NOTE: NOT counting day-name header

      // Remove manual grid height calculations: let CSS/grid auto-size rows.
      const gap = 6 * SCALE;
      tempGrid.style.gap = `${gap}px`;
      tempGrid.style.rowGap = `${gap}px`;
      tempGrid.style.columnGap = `${gap}px`;

      // Use automatic sizing for header + flexible body rows (no explicit pixel heights)
      tempGrid.style.gridTemplateRows = `auto repeat(${effectiveRows}, minmax(0, 1fr))`;
      tempGrid.style.gridAutoFlow = 'row';
      tempGrid.style.alignContent = 'start';
      
      // Add 42 cells (7 columns x 6 rows) including empty days
      const totalBodyCells = effectiveRows * 7; // body cells only (row1..row6)
      const emptyCellsAtStart = firstDay;
      const emptyCellsAtEnd = totalBodyCells - emptyCellsAtStart - daysInMonth;
 
      // Normalize selected persons once for the entire month
      let personsArr;
      if (!selectedPersons || selectedPersons.size === 0) {
        personsArr = Array.from(teams);
      } else {
        personsArr = Array.from(selectedPersons).sort((a, b) => teams.indexOf(a) - teams.indexOf(b));
      }
       
      // Add empty cells at the beginning (placeholders in the first body row before day 1)
      for (let i = 0; i < emptyCellsAtStart; i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'export-empty-day';
        emptyDay.setAttribute('aria-hidden', 'true');
        tempGrid.appendChild(emptyDay);
      }
       
      // Add calendar days
      for (let d = 1; d <= daysInMonth; d++) {
        const day = document.createElement('div');
        day.className = 'export-day';
         
        const date = document.createElement('div');
        date.className = 'export-date';
        date.textContent = d;
        day.appendChild(date);
        
        personsArr.forEach(name => {
          const person = document.createElement('div');
          person.className = 'export-person';
           
          const namePill = document.createElement('span');
          namePill.className = 'export-name-pill';
          namePill.textContent = name;
           
          const assignDate = new Date(year, monthIndex, d);
          const assign = computeAssignment(name, assignDate);
           
          const shiftPill = document.createElement('span');
          shiftPill.className = `export-shift-pill ${assign.shift}`;
          shiftPill.textContent = SHIFT_LABELS[assign.shift] ?? assign.shift;
           
          person.appendChild(namePill);
          person.appendChild(shiftPill);
           
          // Add work cycle label for Day 1-6
          if (assign.cycleIndex >= 1 && assign.cycleIndex <= 6) {
            const workCycle = document.createElement('span');
            workCycle.className = 'export-work-cycle';
            workCycle.textContent = 'D' + assign.cycleIndex;
            person.appendChild(workCycle);
          }
           
          day.appendChild(person);
        });
         
        tempGrid.appendChild(day);
      }
      
      // Add empty cells at the end
      for (let i = 0; i < emptyCellsAtEnd; i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'export-empty-day';
        emptyDay.setAttribute('aria-hidden', 'true');
        tempGrid.appendChild(emptyDay);
      }
      
      // Wait for render
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Generate image
      const canvas = await html2canvas(tempContainer, {
        scale: 2.5,
        useCORS: true,
        backgroundColor: 'whitesmoke',
        width: A4_WIDTH,
        height: A4_HEIGHT
      });
      
      const monthName = getMonthName(monthIndex);
      const monthTwo = String(monthIndex + 1).padStart(2, '0'); // two-digit month
      const outYear = 2026;
      const personsForName = (personsArr && personsArr.length) ? personsArr : Array.from(teams);
      const personNames = personsForName.join('-');
      const filename = `${monthTwo}_${outYear}_${personNames}.png`;

      const blob = await new Promise((resolve) => {
        canvas.toBlob((b) => resolve(b), 'image/png', 1.0);
      });

      // Clean up
      document.body.removeChild(tempContainer);
      document.head.removeChild(styleEl);

      return { blob, filename, monthIndex };
    }

    // ===== Preview modal logic =====
    const previewModal = document.getElementById('previewModal');
    const previewList = document.getElementById('previewList');
    const closePreviewBtn = document.getElementById('closePreview');
    const backPreviewBtn = document.getElementById('backPreview');

    let previewItems = [];
    let previewObjectUrls = [];

    function openPreviewModal(items) {
      // items: [{blob, filename, monthIndex}, ...]
      previewItems = items;
      // create object URLs
      previewObjectUrls = previewItems.map(it => URL.createObjectURL(it.blob));

      // render all images in single page
      previewList.innerHTML = '';
      
      // Add iOS-specific instruction if on iOS device
      if (isIOSDevice()) {
        const iosInstruction = document.querySelector('.preview-instruction');
        if (iosInstruction) {
          iosInstruction.textContent = 'Tap any image to share and save to Photos';
        }
      }
      
      previewItems.forEach((it, idx) => {
        const wrap = document.createElement('div');
        wrap.className = 'preview-wrap';
        const img = document.createElement('img');
        img.className = 'preview-img';
        img.src = previewObjectUrls[idx];
        img.alt = it.filename;
        
        // Update title based on device
        if (isIOSDevice()) {
          img.title = `Tap to share ${getMonthName(it.monthIndex)} 2026`;
        } else {
          img.title = `Click to download ${getMonthName(it.monthIndex)} 2026`;
        }

        // click any image to download/share that image
        img.addEventListener('click', async () => {
          await downloadBlobAs(previewItems[idx].blob, previewItems[idx].filename);
        });

        const label = document.createElement('div');
        label.className = 'preview-label';
        label.textContent = it.filename;
        wrap.appendChild(img);
        wrap.appendChild(label);
        previewList.appendChild(wrap);
      });

      previewModal.classList.add('show');
    }

    // Updated download function with iOS share support
    async function downloadBlobAs(blob, filename) {
      // Check if running on iOS and Web Share API is available
      if (isIOSDevice() && navigator.share) {
        try {
          // For iOS, use Web Share API
          const file = new File([blob], filename, { type: 'image/png' });
          
          // Check if files can be shared
          if (navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({
              files: [file],
              title: 'Shift Schedule',
              text: `Download ${filename}`
            });
            console.log('Successfully shared on iOS');
          } else {
            // Fallback: convert to base64 and use data URL
            const base64 = await blobToBase64(blob);
            const a = document.createElement('a');
            a.href = base64;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
          }
        } catch (error) {
          // User cancelled or error occurred
          if (error.name !== 'AbortError') {
            console.error('Error sharing on iOS:', error);
            // Fallback to regular download
            regularDownload(blob, filename);
          }
        }
      } else {
        // Non-iOS or Web Share API not available
        regularDownload(blob, filename);
      }
    }

    // Regular download for non-iOS devices
    function regularDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Helper function to detect iOS device
    function isIOSDevice() {
      return [
        'iPad Simulator',
        'iPhone Simulator',
        'iPod Simulator',
        'iPad',
        'iPhone',
        'iPod'
      ].includes(navigator.platform)
      // iPad on iOS 13+ detection
      || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
    }

    // Helper function to convert blob to base64 for iOS share
    async function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    // close handlers (revoke URLs)
    function closePreview() {
      previewModal.classList.remove('show');
      previewList.innerHTML = '';
      previewItems = [];
      previewObjectUrls.forEach(u => URL.revokeObjectURL(u));
      previewObjectUrls = [];
    }

    closePreviewBtn.addEventListener('click', closePreview);

    // close modal when clicking outside the download modal
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.classList.remove('show');
      }
    });

    // close modal when clicking outside
    previewModal.addEventListener('click', (e) => {
      if (e.target === previewModal) closePreview();
    });

    // Update the back button handler
    backPreviewBtn.addEventListener('click', () => {
      // Close preview modal
      closePreview();
      
      // Reopen download modal
      modal.classList.add('show');
    });

    // Helper function to get month name
    function getMonthName(monthIndex) {
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                      'July', 'August', 'September', 'October', 'November', 'December'];
      return months[monthIndex];
    }

    // Inject local SVG favicon (no external file, works offline)
    (function installFavicon() {
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#4565fe" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>`;
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      let link = document.querySelector('link[rel="icon"]');
      if (!link) {
        link = document.createElement('link');
        link.rel = 'icon';
        document.head.appendChild(link);
      }
      link.href = url;
      // revoke on unload
      window.addEventListener('unload', () => URL.revokeObjectURL(url));
    })();
  </script>
</body>
</html>